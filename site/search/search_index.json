{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Apunte de Programacion Concurrente - FCEFyN Bienvenido/a al apunte de la materia. Este material culbre desde los conceptos basicos hasta ejemplos aplicados en Java. Como esta organizado Temario general Desarrollo de cada unidad Ejeplos de Codigo Preguntas Tipicas","title":"Inicio"},{"location":"#apunte-de-programacion-concurrente-fcefyn","text":"Bienvenido/a al apunte de la materia. Este material culbre desde los conceptos basicos hasta ejemplos aplicados en Java.","title":"Apunte de Programacion Concurrente - FCEFyN"},{"location":"#como-esta-organizado","text":"Temario general Desarrollo de cada unidad Ejeplos de Codigo Preguntas Tipicas","title":"Como esta organizado"},{"location":"materia-apunte/temario/","text":"Temario Introduccion a la Programacion Concurrente: Unidad 1 Sincronizacion basada en memoria comparida: Sincronizacion y Semaforos: Unidad 2 Gramaticas, Lenguajes y Automatas: Unidad 3 Redes de Petri, Bases de las redes de petri: Unidad 4 Redes de Petri, Propiedades: Unidad 5 Monitores de Concurrencia: Unidad 6 Expresiones Regulares: Unidad 7 Apuntes Practicos: Apuntes Practicos","title":"Temario general"},{"location":"materia-apunte/temario/#temario","text":"Introduccion a la Programacion Concurrente: Unidad 1 Sincronizacion basada en memoria comparida: Sincronizacion y Semaforos: Unidad 2 Gramaticas, Lenguajes y Automatas: Unidad 3 Redes de Petri, Bases de las redes de petri: Unidad 4 Redes de Petri, Propiedades: Unidad 5 Monitores de Concurrencia: Unidad 6 Expresiones Regulares: Unidad 7 Apuntes Practicos: Apuntes Practicos","title":"Temario"},{"location":"unidades/u1-introduccion/","text":"Introduccion a la Programacion Concurrente El problema de la correccion del software Poder garantizar la correcci\u00f3n del software que construimos es una tarea deseable. En algunas aplicaciones es sin dudas crucial (software para equipamiento m\u00e9dico, veh\u00edculos, control de procesos etc.). Estos sistemas cuyas fallas pueden ocasionar da\u00f1os de gran importancia incluyendo p\u00e9rdida de vidas humanas, cat\u00e1strofes ecol\u00f3gicas, grandes p\u00e9rdidas financieras se denominan Sistemas Cr\u00edticos . Limitaciones del testing y la simulacion Tanto el testing como la simulaci\u00f3n involucran experimentos previos al lanzamiento o uso masivo del software. En general ambos m\u00e9todos proveen una serie de entradas al software y estudian el comportamiento del mismo en esos caos. El testing y la simulaci\u00f3n raramente permiten generalizar la usencia de errores, con lo que se pretende afirmar que \u201cEl testing puede confirmar la presencia de errores, pero nunca garantizar su ausencia\u201d. Con lo que se pretende afirmar que la verificaci\u00f3n s\u00f3lo puede hacerlo en teor\u00eda. Verificaci\u00f3n (semi) autom\u00e1tica de software Existen serias limitaciones en lo que respecta a la verificaci\u00f3n autom\u00e1tica de software. Sin embargo, si imponemos algunas restricciones sobre las propiedades que queremos verificar, algunas tareas podr\u00e1n verificarse autom\u00e1ticamente sobre el sistema. El enfoque de modelar Nuestros modelos representan comportamientos verdaderos de programas escritos en java. Los modelos abstractos de programas se centran en los detalles reales relacionados con la representaci\u00f3n de datos, asignaci\u00f3n de recursos y la interacci\u00f3n con el usuario. Introduciremos mecanismos para verificar que el modelo satisface condiciones particulares de seguridad y las propiedades de progreso que son requeridas por las aplicaciones. Estos mecanismos de verificaci\u00f3n son posibles gracias a una herramienta de modelado, con la que comprobaremos exhaustivamente el modelo utilizado, lo que permite comprobar propiedades deseables como indeseables para todas las posibles secuencias de eventos y acciones. Los modelos se basan en m\u00e1quinas de estados finitos y Redes de Petri. Las m\u00e1quinas de estados finitos Se utilizan para especificar el comportamiento din\u00e1mico de los objetos en m\u00e9todos bien conocidos de dise\u00f1o orientado a objetos. tienen una sem\u00e1ntica intuitiva, f\u00e1ciles de entender y una representaci\u00f3n gr\u00e1fica sencilla y tienen propiedades matem\u00e1ticas bien definidas, que facilitan el an\u00e1lisis formal y la comprobaci\u00f3n mec\u00e1nica de sistemas, evitando el tedio y la introducci\u00f3n de errores inherentes al trabajo manual e intelectual de los m\u00e9todos formales. Hay que notar que la representaci\u00f3n gr\u00e1fica de las m\u00e1quinas de estado, limita seriamente la complejidad de los problemas que se pueden abordar. Por lo que se utiliza Redes de Petri. Caracter\u00edsticas reactivas de los sistemas concurrentes Muchos programas concurrentes sueles ser reactivos, es decir su funcionamiento involucra la interacci\u00f3n permanente con el ambiente y otros procesos. Los sistemas reactivos tienen caracter\u00edsticas diferentes a las de los programas transformacionales. En muchos casos estos no computan resultados y suelen no requerir que terminen. Interacci\u00f3n de programas concurrentes Los programas concurrentes est\u00e1n compuestos por procesos (threads o componentes) que necesitan interactuar, existen diferentes formas de interactuar como la memoria compartida o el intercambio de mensajes. Adem\u00e1s, los programas concurrentes deben, en general, colaborar para llegar a un objetivo com\u00fan para lo cual la sincronizaci\u00f3n entre procesos es crucial. Problemas comunes de los programas concurrentes Violaci\u00f3n de propiedades universales ( invariantes ) Starvation(inanici\u00f3n) : uno o m\u00e1s procesos quedan esperando indefinidamente un mensaje o la liberaci\u00f3n de un recurso Deadlock : dos o m\u00e1s procesos esperan mutuamente el avance del otro Problemas de uso no exclusivo de recursos compartidos Livelock : dos o m\u00e1s procesos no pueden avanzar en su ejecuci\u00f3n porque continuamente responden a los cambios en el estado de otros procesos Sem\u00e1ntica de los programas concurrentes Una sem\u00e1ntica t\u00edpica para los programas concurrentes est\u00e1 basada en sistemas de transici\u00f3n de estados. Un sistema de transici\u00f3n de estados es un grafo en el cual: Los nodos son los estados del sistema Las aristas son las transiciones at\u00f3micas de estado en estado, dadas por las sentencias del sistema (l\u00edneas que unen estados) Hay un nodo distinguido que reconoceremos como el estado inicial. Como se ejecutan los procesos concurrentes De acuerdo al modelo computacional descripto: los procesos concurrentes se ejecutan intercalando las acciones at\u00f3micas que los componen, llamamos a esto interliving. El orden en que se ejecutan las acciones at\u00f3micas no puede decirse en general y un mismo par de procesos pueden tener diferentes ejecuciones debido al no determinismo en la elecci\u00f3n de las acciones at\u00f3micas a ejecutar. Razonamiento sobre los programas concurrentes Es dif\u00edcil razonar sobre los programas concurrentes y garantizar que un programa concurrente es correcto tambi\u00e9n es dif\u00edcil. Tiene que ver con que diferentes interlivings de acciones at\u00f3micas pueden llevar a diferentes resultados o comportamientos de los sistemas concurrentes. El n\u00famero de interlivings posibles es en general muy grande lo que hace que el testing dif\u00edcilmente pueda brindarnos confianza. Modelos de programaci\u00f3n concurrente Tenemos que hacer abstracci\u00f3n: acto mental en el que se puede aislar conceptualmente una propiedad o funci\u00f3n concreta de un objeto y se piensa que es, ignorando otras propiedades del mismo. Manera de ocultar los detalles de implementaci\u00f3n de ciertas funcionalidades. Una forma de aliviar el problema de razonar sobre programas concurrentes es considerar representaciones abstractas de estos. Estas representaciones llamadas modelos nos permiten centrarnos en las caracter\u00edsticas particulares que queremos analizar. Las algebras de procesos nos permiten construir estos modelos concentr\u00e1ndose en las propiedades funcionales del sistema concurrente. Para esto es importante considerar los eventos en los cuales cada proceso puede estar involucrado y los patrones de concurrencia Proceso Formalmente un proceso es: unidad de actividad que se caracteriza por la ejecuci\u00f3n de una secuencia de instrucciones, un estado actual y un conjunto de recursos del sistema asociado. El que administra los procesos, sus estados y los recursos es el sistema operativo, proporciona los servicios necesarios para que el usuario pueda ejecutar procesos. Al comienzo de las ejecuciones del programa se inicia la ejecuci\u00f3n de un proceso, este proceso podr\u00eda crear nuevos procesos (proceso padre, proceso hijo). Una vez creado un proceso hijo, la ejecuci\u00f3n de padre e hijo transcurren de manera concurrente Un proceso es un programa en ejecuci\u00f3n. Un proceso simple tiene un hilo de ejecuci\u00f3n. Diferencia entre programa y procesos: un proceso es una actividad que contiene programa, entras y salidas y estados. Procesos cooperantes: se entiende que los procesos interact\u00faan entre s\u00ed. Procesos independientes: no requieren informaci\u00f3n de otros Estados de un proceso Clasificaci\u00f3n en 3 estados Listo: son los que pueden pasar a estado de ejecuci\u00f3n En ejecuci\u00f3n: son los que se est\u00e1n ejecutando en el procesador Bloqueado: est\u00e1n esperando la respuesta de alg\u00fan otro proceso para poder continuar con su ejecuci\u00f3n Clasificaci\u00f3n en 5 estados Activo: est\u00e1 ejecut\u00e1ndose Preparado: todas las tareas est\u00e1n listas para ejecutarse, pero se espera a que un/el procesador quede libre (hay otros procesos m\u00e1s prioritarios en ejecuci\u00f3n) Bloqueado o suspendido: que se termine una operaci\u00f3n de E/S o que se reciba una se\u00f1al de sincronizaci\u00f3n Nonato: indica que el programa realmente existe, pero todav\u00eda no es conocido por el OS Muerto: cuando ha terminado su ejecuci\u00f3n o el sistema operativo ha detectado un error fatal El sistema operativo gestiona los recursos disponibles (memoria, CPU, etc.). Estados en los que se encuentra un proceso en este tipo de sistemas New: el proceso se crea Running: se est\u00e1 ejecutando Waiting: est\u00e1 esperando que se cumpla otro evento Ready: esperando por la CPU Terminated: proceso terminado Estados Son aquellos que compiten con el procesador o est\u00e1n en condiciones de hacerlo. Se dividen en Activos Ejecuci\u00f3n: Estado en el que se encuentra un proceso cuando tiene el control del procesador. En un sistema monoprocesador este estado s\u00f3lo lo puede tener un proceso. Preparado: Aquellos procesos que est\u00e1n dispuestos para ser ejecutados, pero no est\u00e1n en ejecuci\u00f3n por alguna causa (Interrupci\u00f3n, haber entrado en cola estando otro proceso en ejecuci\u00f3n, etc.). Bloqueado: Son los procesos que no pueden ejecutarse de momento por necesitar alg\u00fan recurso no disponible (generalmente recursos de entrada/salida). Inactivos: Suspendido bloqueado: Es el proceso que fue suspendido en espera de un evento, sin que hayan desaparecido las causas de su bloqueo Suspendido programado: Es el proceso que han sido suspendido, pero no tiene causa parta estar bloqueado. Hilos Permiten a una aplicaci\u00f3n realizar varias tareas a la vez. Los distintos hilos de ejecuci\u00f3n comparten recursos: el espacio de memoria, los archivos abiertos, etc. Esta t\u00e9cnica simplificada permite llevar a cabo distintas funciones simult\u00e1neamente. Los hilos de ejecuci\u00f3n que comparten los mismos recursos y estados recursos, son en conjunto conocidos como un proceso. Si un mismo proceso compartan los recursos hace que cualquiera de sus hilos pueda modificarlos. Cuando un hilo modifica un dato en la memoria, los otros hilos acceden a ese dato modificado inmediatamente. Lo que es propio de cada hilo es el contador de programa, la pila de ejecuci\u00f3n y el estado de la CPU (incluyendo el valor de los registros). El proceso sigue en ejecuci\u00f3n mientras al menos uno de sus hilos de ejecuci\u00f3n siga activo. Diferencias entre hilos y procesos Los procesos son independientes, llevan bastante informaci\u00f3n de estados, e interact\u00faan s\u00f3lo a trav\u00e9s de mecanismos de comunicaci\u00f3n dados por el sistema. Los hilos generalmente comparten otros recursos de forma directa. Es m\u00e1s simple y r\u00e1pido cambiar de un hilo a otro dentro del mismo proceso, que cambiar de un proceso a otro. Este fen\u00f3meno se debe a que los hilos comparten datos y espacios de direcciones, mientras que los procesos, al ser independientes, no lo hacen. Ventajas de los hilos Se tarda menos tiempo en crear un hilo nuevo en un proceso existente que crear un nuevo proceso Se tarda menos en terminar un hilo que un proceso Se tarda menos en cambiar entre dos hilos de un mismo proceso. Los hilos aumentan la eficiencia de la comunicaci\u00f3n entre programas en ejecuci\u00f3n. La comunicaci\u00f3n entre procesos debe intervenir el n\u00facleo para ofrecer protecci\u00f3n de los recursos y realizar la comunicaci\u00f3n misma. La comunicaci\u00f3n entre hilos no requiere la invocaci\u00f3n al n\u00facleo. Por lo tanto, si hay una aplicaci\u00f3n que debe implementarse como un conjunto de unidades de ejecuci\u00f3n relacionadas, es m\u00e1s eficiente hacerlo con una colecci\u00f3n de hilos que con una colecci\u00f3n de procesos separados. Cuando un hilo est\u00e1 en ejecuci\u00f3n, posee el acceso a todos los recursos que tiene asignados la tarea. Que tiene un hilo \u2022 Estado \u2022 Contexto del procesador: punto en el que estamos ejecutando. Se usa para reanudar un hilo que fue interrumpido \u2022 Pila de ejecuci\u00f3n donde ira metiendo y sacando instrucciones \u2022 Espacio de almacenamiento est\u00e1tico donde almacenara las variables \u2022 Acceso a los recursos de la tarea que son compartidos por todos los hilos de la tarea Concurrencia Exclusi\u00f3n Mutua y sincronizaci\u00f3n: Estos conceptos se van a dar en distintas plataformas: Multiprogramaci\u00f3n: consiste en la gesti\u00f3n de varios procesos dentro de un sistema monoprocesador Multiprocesamiento: consiste en la gesti\u00f3n de varios procesos dentro de un sistema mono procesador Multiprocesamiento: consiste en la gesti\u00f3n de varios procesos dentro de un sistema multiprocesador Procesamiento distribuido: consiste en la gesti\u00f3n de varios procesos ejecut\u00e1ndose en sistemas de computadoras m\u00faltiples y distribuidos. La concurrencia es fundamental en todas estas \u00e1reas y para el dise\u00f1o. Comprende un gran n\u00famero de cuestiones de dise\u00f1o como: comunicaci\u00f3n entre proceso, compartici\u00f3n y competencia por los recursos, sincronizaci\u00f3n de la ejecuci\u00f3n de varios procesos, asignaci\u00f3n de tiempo. La concurrencia puede presentare en tres contextos diferentes: Multiplicaciones, aplicaciones estructuradas, estructura del sistema operativo. Principios Generales de la concurrencia Multiprogramado con un \u00fanico procesador, los procesos se intercalan en el tiempo aparentando una ejecuci\u00f3n simult\u00e1nea. Los problemas son consecuencia de la velocidad de ejecuci\u00f3n de los procesos que no pueden predecirse y depende de las actividades de otros procesos de la forma en que el sistema operativo trata las interrupciones surgen dificultades Compartir recursos globales es riesgoso, esto ocasiona problemas por esto necesitamos proteger a dichos recursos. Los procesos interact\u00faan entre ellos seg\u00fan el nivel de conocimiento que cada proceso tiene de la existencia de los dem\u00e1s. Existen 3 niveles de conocimiento Los procesos no tienen conocimiento de los dem\u00e1s Los procesos tienen conocimiento indirecto de los dem\u00e1s: No conocen a los otros por sus identificadores per muestran cooperaci\u00f3n Los procesos se conocen directamente: se comunican por el identificador y por trabajar en conjunto Los procesos concurrentes entran en conflicto cuando compiten por el uso del mismo recurso. La ejecuci\u00f3n de un proceso puede influir en el comportamiento de los procesos que compiten. Cuando hay procesos en competencia, se debe solucionar 3 problemas de control: La necesidad de exclusi\u00f3n mutua Hacer que se cumpla la exclusi\u00f3n mutua genera un interbloqueo La inanici\u00f3n Requisitos para la exclusi\u00f3n mutua Solo un proceso de todos los que poseen secciones criticas (partes del c\u00f3digo que varios procesos quieren ejecutar a la vez) por el mismo recurso compartido debe tener permiso para entrar en ella en un momento dado. Un proceso que se interrumpe en una secci\u00f3n no critica debe hacerlo sin interferir a los dem\u00e1s. Deben poder solicitar acceso a una secci\u00f3n critica para luego ser demorado indefinidamente. Si ning\u00fan proceso est\u00e1 en su secci\u00f3n critica, cualquier otro proceso que solicite acceso a su secci\u00f3n critica debe hacerlo sin demoras. Un proceso permanece en su secci\u00f3n critica por tiempo finito Sincronizaci\u00f3n La comunicaci\u00f3n entre procesos implica sincronizaci\u00f3n. El receptor no puede recibir un mensaje hasta que sea enviado por otro proceso. Adem\u00e1s, hace falta especificar que le sucede a un proceso despu\u00e9s de ejecutar una primitiva SEND o RECEIVE. Cuando se ejecuta una primitiva SEND en un proceso hay 2 posibilidades: el proceso emisor se bloque hasta que recibe el mensaje o no se bloquea Cuando se ejecuta una primitiva RECEIVE existen 2 opciones: si previamente se ha enviado alg\u00fan mensaje este es recibido y continua la ejecuci\u00f3n. Si no hay mensaje esperando entonces el proceso se bloquea esperando o contin\u00faa abandonando el intento de recepci\u00f3n. El emisor y el receptor pueden ser bloqueantes o no bloqueantes. Existen 3 tipos de combinaciones (solo se implementan 1 o 2) Envi\u00f3 y recepciones bloqueantes: ambos se bloquean hasta que llegue el mensaje (rendezvous) Envi\u00f3 no bloqueante, recepci\u00f3n bloqueante: el emisor continuo, el receptor se bloquea hasta que legue el mensaje. Es la opci\u00f3n m\u00e1s utilizada y natural Envi\u00f3 y recepci\u00f3n no bloqueante: nadie se espera. Programaci\u00f3n Concurrente: un sistema concurrente es aquel en el que un conjunto de c\u00f3mputos avanza colaborativamente para lo cual est\u00e1 garantizada y coordinada la secuencia de las interacciones o comunicaciones entre diferentes c\u00f3mputos como tambi\u00e9n el acceso a los recursos que se comparten. Paralela: forma de c\u00f3mputo en la que muchas instrucciones se ejecutan simult\u00e1neamente dividiendo el problema en tareas m\u00e1s peque\u00f1as que se resuelven en simultaneo","title":"Unidad 1"},{"location":"unidades/u1-introduccion/#introduccion-a-la-programacion-concurrente","text":"","title":"Introduccion a la Programacion Concurrente"},{"location":"unidades/u1-introduccion/#el-problema-de-la-correccion-del-software","text":"Poder garantizar la correcci\u00f3n del software que construimos es una tarea deseable. En algunas aplicaciones es sin dudas crucial (software para equipamiento m\u00e9dico, veh\u00edculos, control de procesos etc.). Estos sistemas cuyas fallas pueden ocasionar da\u00f1os de gran importancia incluyendo p\u00e9rdida de vidas humanas, cat\u00e1strofes ecol\u00f3gicas, grandes p\u00e9rdidas financieras se denominan Sistemas Cr\u00edticos .","title":"El problema de la correccion del software"},{"location":"unidades/u1-introduccion/#limitaciones-del-testing-y-la-simulacion","text":"Tanto el testing como la simulaci\u00f3n involucran experimentos previos al lanzamiento o uso masivo del software. En general ambos m\u00e9todos proveen una serie de entradas al software y estudian el comportamiento del mismo en esos caos. El testing y la simulaci\u00f3n raramente permiten generalizar la usencia de errores, con lo que se pretende afirmar que \u201cEl testing puede confirmar la presencia de errores, pero nunca garantizar su ausencia\u201d. Con lo que se pretende afirmar que la verificaci\u00f3n s\u00f3lo puede hacerlo en teor\u00eda.","title":"Limitaciones del testing y la simulacion"},{"location":"unidades/u1-introduccion/#verificacion-semi-automatica-de-software","text":"Existen serias limitaciones en lo que respecta a la verificaci\u00f3n autom\u00e1tica de software. Sin embargo, si imponemos algunas restricciones sobre las propiedades que queremos verificar, algunas tareas podr\u00e1n verificarse autom\u00e1ticamente sobre el sistema.","title":"Verificaci\u00f3n (semi) autom\u00e1tica de software"},{"location":"unidades/u1-introduccion/#el-enfoque-de-modelar","text":"Nuestros modelos representan comportamientos verdaderos de programas escritos en java. Los modelos abstractos de programas se centran en los detalles reales relacionados con la representaci\u00f3n de datos, asignaci\u00f3n de recursos y la interacci\u00f3n con el usuario. Introduciremos mecanismos para verificar que el modelo satisface condiciones particulares de seguridad y las propiedades de progreso que son requeridas por las aplicaciones. Estos mecanismos de verificaci\u00f3n son posibles gracias a una herramienta de modelado, con la que comprobaremos exhaustivamente el modelo utilizado, lo que permite comprobar propiedades deseables como indeseables para todas las posibles secuencias de eventos y acciones. Los modelos se basan en m\u00e1quinas de estados finitos y Redes de Petri. Las m\u00e1quinas de estados finitos Se utilizan para especificar el comportamiento din\u00e1mico de los objetos en m\u00e9todos bien conocidos de dise\u00f1o orientado a objetos. tienen una sem\u00e1ntica intuitiva, f\u00e1ciles de entender y una representaci\u00f3n gr\u00e1fica sencilla y tienen propiedades matem\u00e1ticas bien definidas, que facilitan el an\u00e1lisis formal y la comprobaci\u00f3n mec\u00e1nica de sistemas, evitando el tedio y la introducci\u00f3n de errores inherentes al trabajo manual e intelectual de los m\u00e9todos formales. Hay que notar que la representaci\u00f3n gr\u00e1fica de las m\u00e1quinas de estado, limita seriamente la complejidad de los problemas que se pueden abordar. Por lo que se utiliza Redes de Petri.","title":"El enfoque de modelar"},{"location":"unidades/u1-introduccion/#caracteristicas-reactivas-de-los-sistemas-concurrentes","text":"Muchos programas concurrentes sueles ser reactivos, es decir su funcionamiento involucra la interacci\u00f3n permanente con el ambiente y otros procesos. Los sistemas reactivos tienen caracter\u00edsticas diferentes a las de los programas transformacionales. En muchos casos estos no computan resultados y suelen no requerir que terminen.","title":"Caracter\u00edsticas reactivas de los sistemas concurrentes"},{"location":"unidades/u1-introduccion/#interaccion-de-programas-concurrentes","text":"Los programas concurrentes est\u00e1n compuestos por procesos (threads o componentes) que necesitan interactuar, existen diferentes formas de interactuar como la memoria compartida o el intercambio de mensajes. Adem\u00e1s, los programas concurrentes deben, en general, colaborar para llegar a un objetivo com\u00fan para lo cual la sincronizaci\u00f3n entre procesos es crucial.","title":"Interacci\u00f3n de programas concurrentes"},{"location":"unidades/u1-introduccion/#problemas-comunes-de-los-programas-concurrentes","text":"Violaci\u00f3n de propiedades universales ( invariantes ) Starvation(inanici\u00f3n) : uno o m\u00e1s procesos quedan esperando indefinidamente un mensaje o la liberaci\u00f3n de un recurso Deadlock : dos o m\u00e1s procesos esperan mutuamente el avance del otro Problemas de uso no exclusivo de recursos compartidos Livelock : dos o m\u00e1s procesos no pueden avanzar en su ejecuci\u00f3n porque continuamente responden a los cambios en el estado de otros procesos","title":"Problemas comunes de los programas concurrentes"},{"location":"unidades/u1-introduccion/#semantica-de-los-programas-concurrentes","text":"Una sem\u00e1ntica t\u00edpica para los programas concurrentes est\u00e1 basada en sistemas de transici\u00f3n de estados. Un sistema de transici\u00f3n de estados es un grafo en el cual: Los nodos son los estados del sistema Las aristas son las transiciones at\u00f3micas de estado en estado, dadas por las sentencias del sistema (l\u00edneas que unen estados) Hay un nodo distinguido que reconoceremos como el estado inicial.","title":"Sem\u00e1ntica de los programas concurrentes"},{"location":"unidades/u1-introduccion/#como-se-ejecutan-los-procesos-concurrentes","text":"De acuerdo al modelo computacional descripto: los procesos concurrentes se ejecutan intercalando las acciones at\u00f3micas que los componen, llamamos a esto interliving. El orden en que se ejecutan las acciones at\u00f3micas no puede decirse en general y un mismo par de procesos pueden tener diferentes ejecuciones debido al no determinismo en la elecci\u00f3n de las acciones at\u00f3micas a ejecutar.","title":"Como se ejecutan los procesos concurrentes"},{"location":"unidades/u1-introduccion/#razonamiento-sobre-los-programas-concurrentes","text":"Es dif\u00edcil razonar sobre los programas concurrentes y garantizar que un programa concurrente es correcto tambi\u00e9n es dif\u00edcil. Tiene que ver con que diferentes interlivings de acciones at\u00f3micas pueden llevar a diferentes resultados o comportamientos de los sistemas concurrentes. El n\u00famero de interlivings posibles es en general muy grande lo que hace que el testing dif\u00edcilmente pueda brindarnos confianza.","title":"Razonamiento sobre los programas concurrentes"},{"location":"unidades/u1-introduccion/#modelos-de-programacion-concurrente","text":"Tenemos que hacer abstracci\u00f3n: acto mental en el que se puede aislar conceptualmente una propiedad o funci\u00f3n concreta de un objeto y se piensa que es, ignorando otras propiedades del mismo. Manera de ocultar los detalles de implementaci\u00f3n de ciertas funcionalidades. Una forma de aliviar el problema de razonar sobre programas concurrentes es considerar representaciones abstractas de estos. Estas representaciones llamadas modelos nos permiten centrarnos en las caracter\u00edsticas particulares que queremos analizar. Las algebras de procesos nos permiten construir estos modelos concentr\u00e1ndose en las propiedades funcionales del sistema concurrente. Para esto es importante considerar los eventos en los cuales cada proceso puede estar involucrado y los patrones de concurrencia","title":"Modelos de programaci\u00f3n concurrente"},{"location":"unidades/u1-introduccion/#proceso","text":"Formalmente un proceso es: unidad de actividad que se caracteriza por la ejecuci\u00f3n de una secuencia de instrucciones, un estado actual y un conjunto de recursos del sistema asociado. El que administra los procesos, sus estados y los recursos es el sistema operativo, proporciona los servicios necesarios para que el usuario pueda ejecutar procesos. Al comienzo de las ejecuciones del programa se inicia la ejecuci\u00f3n de un proceso, este proceso podr\u00eda crear nuevos procesos (proceso padre, proceso hijo). Una vez creado un proceso hijo, la ejecuci\u00f3n de padre e hijo transcurren de manera concurrente Un proceso es un programa en ejecuci\u00f3n. Un proceso simple tiene un hilo de ejecuci\u00f3n. Diferencia entre programa y procesos: un proceso es una actividad que contiene programa, entras y salidas y estados. Procesos cooperantes: se entiende que los procesos interact\u00faan entre s\u00ed. Procesos independientes: no requieren informaci\u00f3n de otros","title":"Proceso"},{"location":"unidades/u1-introduccion/#estados-de-un-proceso","text":"Clasificaci\u00f3n en 3 estados Listo: son los que pueden pasar a estado de ejecuci\u00f3n En ejecuci\u00f3n: son los que se est\u00e1n ejecutando en el procesador Bloqueado: est\u00e1n esperando la respuesta de alg\u00fan otro proceso para poder continuar con su ejecuci\u00f3n Clasificaci\u00f3n en 5 estados Activo: est\u00e1 ejecut\u00e1ndose Preparado: todas las tareas est\u00e1n listas para ejecutarse, pero se espera a que un/el procesador quede libre (hay otros procesos m\u00e1s prioritarios en ejecuci\u00f3n) Bloqueado o suspendido: que se termine una operaci\u00f3n de E/S o que se reciba una se\u00f1al de sincronizaci\u00f3n Nonato: indica que el programa realmente existe, pero todav\u00eda no es conocido por el OS Muerto: cuando ha terminado su ejecuci\u00f3n o el sistema operativo ha detectado un error fatal El sistema operativo gestiona los recursos disponibles (memoria, CPU, etc.). Estados en los que se encuentra un proceso en este tipo de sistemas New: el proceso se crea Running: se est\u00e1 ejecutando Waiting: est\u00e1 esperando que se cumpla otro evento Ready: esperando por la CPU Terminated: proceso terminado","title":"Estados de un proceso"},{"location":"unidades/u1-introduccion/#estados","text":"Son aquellos que compiten con el procesador o est\u00e1n en condiciones de hacerlo. Se dividen en Activos Ejecuci\u00f3n: Estado en el que se encuentra un proceso cuando tiene el control del procesador. En un sistema monoprocesador este estado s\u00f3lo lo puede tener un proceso. Preparado: Aquellos procesos que est\u00e1n dispuestos para ser ejecutados, pero no est\u00e1n en ejecuci\u00f3n por alguna causa (Interrupci\u00f3n, haber entrado en cola estando otro proceso en ejecuci\u00f3n, etc.). Bloqueado: Son los procesos que no pueden ejecutarse de momento por necesitar alg\u00fan recurso no disponible (generalmente recursos de entrada/salida). Inactivos: Suspendido bloqueado: Es el proceso que fue suspendido en espera de un evento, sin que hayan desaparecido las causas de su bloqueo Suspendido programado: Es el proceso que han sido suspendido, pero no tiene causa parta estar bloqueado.","title":"Estados"},{"location":"unidades/u1-introduccion/#hilos","text":"Permiten a una aplicaci\u00f3n realizar varias tareas a la vez. Los distintos hilos de ejecuci\u00f3n comparten recursos: el espacio de memoria, los archivos abiertos, etc. Esta t\u00e9cnica simplificada permite llevar a cabo distintas funciones simult\u00e1neamente. Los hilos de ejecuci\u00f3n que comparten los mismos recursos y estados recursos, son en conjunto conocidos como un proceso. Si un mismo proceso compartan los recursos hace que cualquiera de sus hilos pueda modificarlos. Cuando un hilo modifica un dato en la memoria, los otros hilos acceden a ese dato modificado inmediatamente. Lo que es propio de cada hilo es el contador de programa, la pila de ejecuci\u00f3n y el estado de la CPU (incluyendo el valor de los registros). El proceso sigue en ejecuci\u00f3n mientras al menos uno de sus hilos de ejecuci\u00f3n siga activo.","title":"Hilos"},{"location":"unidades/u1-introduccion/#diferencias-entre-hilos-y-procesos","text":"Los procesos son independientes, llevan bastante informaci\u00f3n de estados, e interact\u00faan s\u00f3lo a trav\u00e9s de mecanismos de comunicaci\u00f3n dados por el sistema. Los hilos generalmente comparten otros recursos de forma directa. Es m\u00e1s simple y r\u00e1pido cambiar de un hilo a otro dentro del mismo proceso, que cambiar de un proceso a otro. Este fen\u00f3meno se debe a que los hilos comparten datos y espacios de direcciones, mientras que los procesos, al ser independientes, no lo hacen.","title":"Diferencias entre hilos y procesos"},{"location":"unidades/u1-introduccion/#ventajas-de-los-hilos","text":"Se tarda menos tiempo en crear un hilo nuevo en un proceso existente que crear un nuevo proceso Se tarda menos en terminar un hilo que un proceso Se tarda menos en cambiar entre dos hilos de un mismo proceso. Los hilos aumentan la eficiencia de la comunicaci\u00f3n entre programas en ejecuci\u00f3n. La comunicaci\u00f3n entre procesos debe intervenir el n\u00facleo para ofrecer protecci\u00f3n de los recursos y realizar la comunicaci\u00f3n misma. La comunicaci\u00f3n entre hilos no requiere la invocaci\u00f3n al n\u00facleo. Por lo tanto, si hay una aplicaci\u00f3n que debe implementarse como un conjunto de unidades de ejecuci\u00f3n relacionadas, es m\u00e1s eficiente hacerlo con una colecci\u00f3n de hilos que con una colecci\u00f3n de procesos separados. Cuando un hilo est\u00e1 en ejecuci\u00f3n, posee el acceso a todos los recursos que tiene asignados la tarea.","title":"Ventajas de los hilos"},{"location":"unidades/u1-introduccion/#que-tiene-un-hilo","text":"\u2022 Estado \u2022 Contexto del procesador: punto en el que estamos ejecutando. Se usa para reanudar un hilo que fue interrumpido \u2022 Pila de ejecuci\u00f3n donde ira metiendo y sacando instrucciones \u2022 Espacio de almacenamiento est\u00e1tico donde almacenara las variables \u2022 Acceso a los recursos de la tarea que son compartidos por todos los hilos de la tarea","title":"Que tiene un hilo"},{"location":"unidades/u1-introduccion/#concurrencia","text":"Exclusi\u00f3n Mutua y sincronizaci\u00f3n: Estos conceptos se van a dar en distintas plataformas: Multiprogramaci\u00f3n: consiste en la gesti\u00f3n de varios procesos dentro de un sistema monoprocesador Multiprocesamiento: consiste en la gesti\u00f3n de varios procesos dentro de un sistema mono procesador Multiprocesamiento: consiste en la gesti\u00f3n de varios procesos dentro de un sistema multiprocesador Procesamiento distribuido: consiste en la gesti\u00f3n de varios procesos ejecut\u00e1ndose en sistemas de computadoras m\u00faltiples y distribuidos. La concurrencia es fundamental en todas estas \u00e1reas y para el dise\u00f1o. Comprende un gran n\u00famero de cuestiones de dise\u00f1o como: comunicaci\u00f3n entre proceso, compartici\u00f3n y competencia por los recursos, sincronizaci\u00f3n de la ejecuci\u00f3n de varios procesos, asignaci\u00f3n de tiempo. La concurrencia puede presentare en tres contextos diferentes: Multiplicaciones, aplicaciones estructuradas, estructura del sistema operativo.","title":"Concurrencia"},{"location":"unidades/u1-introduccion/#principios-generales-de-la-concurrencia","text":"Multiprogramado con un \u00fanico procesador, los procesos se intercalan en el tiempo aparentando una ejecuci\u00f3n simult\u00e1nea. Los problemas son consecuencia de la velocidad de ejecuci\u00f3n de los procesos que no pueden predecirse y depende de las actividades de otros procesos de la forma en que el sistema operativo trata las interrupciones surgen dificultades Compartir recursos globales es riesgoso, esto ocasiona problemas por esto necesitamos proteger a dichos recursos. Los procesos interact\u00faan entre ellos seg\u00fan el nivel de conocimiento que cada proceso tiene de la existencia de los dem\u00e1s. Existen 3 niveles de conocimiento Los procesos no tienen conocimiento de los dem\u00e1s Los procesos tienen conocimiento indirecto de los dem\u00e1s: No conocen a los otros por sus identificadores per muestran cooperaci\u00f3n Los procesos se conocen directamente: se comunican por el identificador y por trabajar en conjunto Los procesos concurrentes entran en conflicto cuando compiten por el uso del mismo recurso. La ejecuci\u00f3n de un proceso puede influir en el comportamiento de los procesos que compiten. Cuando hay procesos en competencia, se debe solucionar 3 problemas de control: La necesidad de exclusi\u00f3n mutua Hacer que se cumpla la exclusi\u00f3n mutua genera un interbloqueo La inanici\u00f3n","title":"Principios Generales de la concurrencia"},{"location":"unidades/u1-introduccion/#requisitos-para-la-exclusion-mutua","text":"Solo un proceso de todos los que poseen secciones criticas (partes del c\u00f3digo que varios procesos quieren ejecutar a la vez) por el mismo recurso compartido debe tener permiso para entrar en ella en un momento dado. Un proceso que se interrumpe en una secci\u00f3n no critica debe hacerlo sin interferir a los dem\u00e1s. Deben poder solicitar acceso a una secci\u00f3n critica para luego ser demorado indefinidamente. Si ning\u00fan proceso est\u00e1 en su secci\u00f3n critica, cualquier otro proceso que solicite acceso a su secci\u00f3n critica debe hacerlo sin demoras. Un proceso permanece en su secci\u00f3n critica por tiempo finito","title":"Requisitos para la exclusi\u00f3n mutua"},{"location":"unidades/u1-introduccion/#sincronizacion","text":"La comunicaci\u00f3n entre procesos implica sincronizaci\u00f3n. El receptor no puede recibir un mensaje hasta que sea enviado por otro proceso. Adem\u00e1s, hace falta especificar que le sucede a un proceso despu\u00e9s de ejecutar una primitiva SEND o RECEIVE. Cuando se ejecuta una primitiva SEND en un proceso hay 2 posibilidades: el proceso emisor se bloque hasta que recibe el mensaje o no se bloquea Cuando se ejecuta una primitiva RECEIVE existen 2 opciones: si previamente se ha enviado alg\u00fan mensaje este es recibido y continua la ejecuci\u00f3n. Si no hay mensaje esperando entonces el proceso se bloquea esperando o contin\u00faa abandonando el intento de recepci\u00f3n. El emisor y el receptor pueden ser bloqueantes o no bloqueantes. Existen 3 tipos de combinaciones (solo se implementan 1 o 2) Envi\u00f3 y recepciones bloqueantes: ambos se bloquean hasta que llegue el mensaje (rendezvous) Envi\u00f3 no bloqueante, recepci\u00f3n bloqueante: el emisor continuo, el receptor se bloquea hasta que legue el mensaje. Es la opci\u00f3n m\u00e1s utilizada y natural Envi\u00f3 y recepci\u00f3n no bloqueante: nadie se espera.","title":"Sincronizaci\u00f3n"},{"location":"unidades/u1-introduccion/#programacion","text":"Concurrente: un sistema concurrente es aquel en el que un conjunto de c\u00f3mputos avanza colaborativamente para lo cual est\u00e1 garantizada y coordinada la secuencia de las interacciones o comunicaciones entre diferentes c\u00f3mputos como tambi\u00e9n el acceso a los recursos que se comparten. Paralela: forma de c\u00f3mputo en la que muchas instrucciones se ejecutan simult\u00e1neamente dividiendo el problema en tareas m\u00e1s peque\u00f1as que se resuelven en simultaneo","title":"Programaci\u00f3n"},{"location":"unidades/u1-introduccion/#_1","text":"","title":""},{"location":"unidades/u2-sincronizacion/","text":"Sincronizacion basada en memoria comparida: Sincronizacion y Semaforos","title":"Unidad 2"},{"location":"unidades/u2-sincronizacion/#sincronizacion-basada-en-memoria-comparida-sincronizacion-y-semaforos","text":"","title":"Sincronizacion basada en memoria comparida: Sincronizacion y Semaforos"},{"location":"unidades/u3-gramatica/","text":"Gramaticas, lenguajes y automatas","title":"Unidad 3"},{"location":"unidades/u3-gramatica/#gramaticas-lenguajes-y-automatas","text":"","title":"Gramaticas, lenguajes y automatas"},{"location":"unidades/u4-bases_redes_petri/","text":"Bases de las Redes de Petri","title":"Unidad 4"},{"location":"unidades/u4-bases_redes_petri/#bases-de-las-redes-de-petri","text":"","title":"Bases de las Redes de Petri"},{"location":"unidades/u5-propiedades_redes_petri/","text":"Redes de Petri: Propiedades","title":"Unidad 5"},{"location":"unidades/u5-propiedades_redes_petri/#redes-de-petri-propiedades","text":"","title":"Redes de Petri: Propiedades"},{"location":"unidades/u6-monitor-concurrencia/","text":"Monitor de Concurrencia","title":"Unidad 6"},{"location":"unidades/u6-monitor-concurrencia/#monitor-de-concurrencia","text":"","title":"Monitor de Concurrencia"},{"location":"unidades/u7-regex/","text":"Expresiones Regulares","title":"Unidad 7"},{"location":"unidades/u7-regex/#expresiones-regulares","text":"","title":"Expresiones Regulares"},{"location":"unidades/u8-Apuntes-practicos/","text":"Apuntes Practicos","title":"Apuntes pr\u00e1cticos"},{"location":"unidades/u8-Apuntes-practicos/#apuntes-practicos","text":"","title":"Apuntes Practicos"}]}